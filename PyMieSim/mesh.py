#!/usr/bin/env python
# -*- coding: utf-8 -*-

from typing import Optional, NoReturn
from pydantic.dataclasses import dataclass
from pydantic import ConfigDict
import numpy

from PyMieSim.binary.interface_fibonacci import FibonacciMesh as CPPFibonacciMesh
from MPSPlots.render3D import SceneList as SceneList3D

config_dict = ConfigDict(
    kw_only=True,
    extra='forbid',
    slots=True
)


@dataclass(config=config_dict)
class FibonacciMesh:
    """
    Represents an angular mesh using a Fibonacci sphere distribution, where each point
    covers an equivalent solid angle. This type of mesh is useful for simulating angular
    distributions in light scattering experiments.

    The mesh is defined by a numerical aperture and a number of sampling points, with
    additional control over the orientation and rotation of the mesh.

    Parameters
    ----------
    max_angle : float
        The maximum angle in radians, typically defined by the numerical aperture of the imaging system.
    sampling : int
        The number of points distributed across the mesh. Higher values result in finer resolution.
    phi_offset : float
        Angle offset in the azimuthal (parallel to incident light polarization) direction in degrees.
    gamma_offset : float
        Angle offset in the polar (perpendicular to incident light polarization) direction in degrees.
    rotation_angle : Optional[float], default=0.0
        Rotation of the entire mesh around its principal axis, in degrees.

    Attributes
    ----------
    cartesian_coordinates : numpy.ndarray
        Cartesian coordinates of the mesh points, calculated during initialization.
    d_omega_radian : float
        Differential solid angle element in radians for each point on the mesh.
    d_omega_degree : float
        Differential solid angle element in degrees for each point on the mesh.
    omega_radian : float
        Total solid angle covered by the mesh in radians.
    omega_degree : float
        Total solid angle covered by the mesh in degrees.

    Methods
    -------
    initialize_properties():
        Initializes additional mesh properties based on the Fibonacci distribution generated by the binding.
    projection_HV_vector() -> tuple:
        Returns the parallel and perpendicular projections of the mesh on the horizontal and vertical base vectors as vectors.
    projection_HV_scalar() -> tuple:
        Returns the parallel and perpendicular projections of the mesh on the horizontal and vertical base vectors as scalar values.
    projection_on_base_scalar(vector, base_vector) -> numpy.ndarray:
        Computes the scalar projection of a given vector onto a base vector.
    projection_on_base_vector(vector, base_vector) -> numpy.ndarray:
        Computes the vector projection of a given vector onto a base vector.
    plot() -> SceneList3D:
        Plots the mesh using 3D rendering and returns a 3D scene list object.
    get_cartesian_coordinates() -> numpy.ndarray:
        Returns the Cartesian coordinates of the mesh points.
    get_axis_vector() -> numpy.ndarray:
        Returns the axis vector corresponding to the phi and gamma offsets.
    rotate_around_axis(rotation_angle) -> NoReturn:
        Rotates the mesh around its principal axis by a specified angle.

    """

    max_angle: float
    sampling: int
    phi_offset: float
    gamma_offset: float
    rotation_angle: Optional[float] = 0.0

    def __post_init__(self):
        """
        Initializes internal properties and binds the C++ implementation of the Fibonacci
        mesh to the Python class.
        """
        self.structured = False
        self._para = None
        self._perp = None

        self.vertical_vector = numpy.array([1, 0, 0])
        self.horizontal_vector = numpy.array([0, 1, 0])

        self.binding = CPPFibonacciMesh(
            sampling=self.sampling,
            max_angle=self.max_angle,
            phi_offset=numpy.deg2rad(self.phi_offset),
            gamma_offset=numpy.deg2rad(self.gamma_offset),
            rotation_angle=self.rotation_angle
        )

        self.initialize_properties()
        self.binding.compute_vector_field()

    @property
    def perpendicular_vector(self):
        """
        Returns the vector field component perpendicular to the incident light direction.

        Returns
        -------
        numpy.ndarray
            Array representing the perpendicular vector field.
        """
        return self.binding.perpendicular_vector

    @property
    def parallel_vector(self):
        """
        Returns the vector field component parallel to the incident light direction.

        Returns
        -------
        numpy.ndarray
            Array representing the parallel vector field.
        """
        return self.binding.parallel_vector

    @property
    def horizontal_to_perpendicular(self):
        """
        Returns the projection of the horizontal base vector onto the perpendicular component.

        Returns
        -------
        numpy.ndarray
            The horizontal projection onto the perpendicular vector field.
        """
        return self.binding.horizontal_to_perpendicular_vector

    @property
    def horizontal_to_parallel(self):
        """
        Returns the projection of the horizontal base vector onto the parallel component.

        Returns
        -------
        numpy.ndarray
            The horizontal projection onto the parallel vector field.
        """
        return self.binding.horizontal_to_parallel_vector

    @property
    def vertical_to_perpendicular(self):
        """
        Returns the projection of the vertical base vector onto the perpendicular component.

        Returns
        -------
        numpy.ndarray
            The vertical projection onto the perpendicular vector field.
        """
        return self.binding.perpendicular_vector

    @property
    def vertical_to_parallel(self):
        """
        Returns the projection of the vertical base vector onto the parallel component.

        Returns
        -------
        numpy.ndarray
            The vertical projection onto the parallel vector field.
        """
        return self.binding.parallel_vector

    def get_phi(self, unit: str = 'radian'):
        """
        Returns the azimuthal angle (phi) of the mesh in the specified unit.

        Parameters
        ----------
        unit : str, optional
            The unit of the angle to return, either 'radian' or 'degree'. Default is 'radian'.

        Returns
        -------
        numpy.ndarray
            Array of phi values in the specified unit.
        """
        if unit.lower() in ['rad', 'radian']:
            return self.binding.phi
        elif unit.lower() in ['deg', 'degree']:
            return numpy.rad2deg(self.binding.phi)

    def get_theta(self, unit: str = 'radian'):
        """
        Returns the polar angle (theta) of the mesh in the specified unit.

        Parameters
        ----------
        unit : str, optional
            The unit of the angle to return, either 'radian' or 'degree'. Default is 'radian'.

        Returns
        -------
        numpy.ndarray
            Array of theta values in the specified unit.
        """
        if unit.lower() in ['rad', 'radian']:
            return self.binding.theta
        elif unit.lower() in ['deg', 'degree']:
            return numpy.rad2deg(self.binding.theta)

    @property
    def X(self) -> numpy.ndarray:
        """
        Returns the X-coordinate of the mesh points.

        Returns
        -------
        numpy.ndarray
            Array of X-coordinates.
        """
        return self.binding.x

    @property
    def Y(self) -> numpy.ndarray:
        """
        Returns the Y-coordinate of the mesh points.

        Returns
        -------
        numpy.ndarray
            Array of Y-coordinates.
        """
        return self.binding.y

    @property
    def Z(self) -> numpy.ndarray:
        """
        Returns the Z-coordinate of the mesh points.

        Returns
        -------
        numpy.ndarray
            Array of Z-coordinates.
        """
        return self.binding.z

    def initialize_properties(self):
        """
        Initializes additional properties of the Fibonacci mesh based on the underlying
        C++ implementation.

        This includes calculating Cartesian coordinates and solid angles for each point on the mesh.
        """
        self.cartesian_coordinates = numpy.column_stack((self.binding.x, self.binding.y, self.binding.z))
        self.d_omega_radian = self.binding.d_omega
        self.d_omega_degree = self.binding.d_omega * (180 / numpy.pi) ** 2
        self.omega_radian = self.binding.omega
        self.omega_degree = self.binding.omega * (180 / numpy.pi) ** 2

    def plot(self) -> SceneList3D:
        """
        Plots the Fibonacci mesh using 3D rendering.

        Returns
        -------
        SceneList3D
            A 3D scene list object containing the rendered mesh plot.
        """
        figure = SceneList3D()
        ax = figure.append_ax()
        self._add_mesh_to_ax_(ax)

        return figure

    def get_cartesian_coordinates(self) -> numpy.ndarray:
        """
        Returns the Cartesian coordinates of the mesh points.

        Returns
        -------
        numpy.ndarray
            Array of Cartesian coordinates (X, Y, Z) for the mesh points.
        """
        return numpy.c_[self.X, self.Y, self.Z].T

    def get_axis_vector(self) -> numpy.ndarray:
        """
        Returns the axis vector corresponding to the phi and gamma offsets.

        Returns
        -------
        numpy.ndarray
            The axis vector normalized to unit length.
        """
        x, y, z = self.get_cartesian_coordinates()
        axis_vector = numpy.array([x[0], y[0], z[0]])

        norm = numpy.sqrt(numpy.square(axis_vector).sum())

        return axis_vector / norm

    def rotate_around_axis(self, rotation_angle: float) -> NoReturn:
        """
        Rotates the mesh around its principal axis by a specified angle.

        Parameters
        ----------
        rotation_angle : float
            The angle in degrees by which to rotate the mesh.

        Returns
        -------
        None
        """
        self.binding.rotate_around_axis(rotation_angle)

    def projection_HV_vector(self) -> tuple:
        """
        Projects the vertical and horizontal base vectors onto the parallel and perpendicular components
        of the mesh, returning these projections as vectors.

        The projections help visualize the relationship between the mesh's angular distribution and
        the incident light polarization directions.

        Returns
        -------
        tuple of numpy.ndarray
            A tuple where the first element is the projection of the vertical and horizontal base vectors
            onto the parallel vector field, and the second element is the projection onto the perpendicular
            vector field.
            Each of these projections is a 2D array of shape (2, 3), where:
                - The first row corresponds to the projection onto the vertical base vector.
                - The second row corresponds to the projection onto the horizontal base vector.
        """
        parallel_projection = [
            self.projection_on_base_vector(
                vector=self.vertical_to_parallel,
                base_vector=X
            ) for X in [self.vertical_vector, self.horizontal_vector]
        ]

        perpendicular_projection = [
            self.projection_on_base_vector(
                vector=self.vertical_to_perpendicular,
                base_vector=X
            ) for X in [self.vertical_vector, self.horizontal_vector]
        ]

        return numpy.array(parallel_projection), numpy.array(perpendicular_projection)

    def projection_HV_scalar(self) -> tuple:
        """
        Projects the vertical and horizontal base vectors onto the parallel and perpendicular components
        of the mesh, returning these projections as scalar values (dot products).

        This method calculates the scalar projection, which represents the magnitude of the component
        of the vector field along the base vectors.

        Returns
        -------
        tuple of numpy.ndarray
            A tuple where the first element is the scalar projection of the vertical and horizontal base vectors
            onto the parallel vector field, and the second element is the scalar projection onto the perpendicular
            vector field.
            Each of these projections is a 1D array of length 2, where:
                - The first element corresponds to the projection onto the vertical base vector.
                - The second element corresponds to the projection onto the horizontal base vector.

        """
        parallel_projection = [
            self.projection_on_base_scalar(
                vector=self.vertical_to_parallel,
                base_vector=X
            ) for X in [self.vertical_vector, self.horizontal_vector]
        ]

        perpendicular_projection = [
            self.projection_on_base_scalar(
                vector=self.vertical_to_perpendicular,
                base_vector=X
            ) for X in [self.vertical_vector, self.horizontal_vector]
        ]

        return numpy.array(parallel_projection), numpy.array(perpendicular_projection)

    def projection_on_base_scalar(self, vector: numpy.ndarray, base_vector: numpy.ndarray) -> numpy.ndarray:
        r"""
        Computes the scalar projection (dot product) of a given vector onto a base vector.

        This method calculates the magnitude of the projection of `vector` along the direction
        of `base_vector`. The scalar projection is useful for understanding how much of
        `vector` is aligned with `base_vector`.

        Parameters
        ----------
        vector : numpy.ndarray
            The vector to be projected. It should be a 1D array representing the vector field component
            (either parallel or perpendicular) of the mesh.
        base_vector : numpy.ndarray
            The base vector onto which the projection is made. It should be a 1D array, typically
            representing the horizontal or vertical base direction.

        Returns
        -------
        numpy.ndarray
            The scalar projection of `vector` onto `base_vector`, which is a single numeric value.
            This value represents the magnitude of the component of `vector` that is aligned with
            `base_vector`.

        Notes
        -----
        The scalar projection is calculated as the dot product of `vector` and `base_vector`:

        .. math::
            \text{scalar projection} = \vec{v} \cdot \vec{b}

        where :math:`\vec{v}` is the input vector and :math:`\vec{b}` is the base vector.
        """
        return vector.dot(base_vector)

    def projection_on_base_vector(self, vector: numpy.ndarray, base_vector: numpy.ndarray) -> numpy.ndarray:
        r"""
        Computes the vector projection of a given vector onto a base vector.

        This method calculates the projection of `vector` along the direction of `base_vector`
        and returns a new vector that represents the component of `vector` aligned with
        `base_vector`. This is useful for decomposing vectors in terms of directional components.

        Parameters
        ----------
        vector : numpy.ndarray
            The vector to be projected. It should be a 1D array representing the vector field component
            (either parallel or perpendicular) of the mesh.
        base_vector : numpy.ndarray
            The base vector onto which the projection is made. It should be a 1D array, typically
            representing the horizontal or vertical base direction.

        Returns
        -------
        numpy.ndarray
            The vector projection of `vector` onto `base_vector`, which is a vector in the direction
            of `base_vector`. The resulting vector represents the part of `vector` that lies along
            `base_vector`.

        Notes
        -----
        The vector projection is calculated as:

        .. math::
            \text{vector projection} = \left( \frac{\vec{v} \cdot \vec{b}}{\vec{b} \cdot \vec{b}} \right) \vec{b}

        where :math:`\vec{v}` is the input vector and :math:`\vec{b}` is the base vector. This formula gives the projection
        of `vector` along the direction of `base_vector`.

        The method first computes the scalar projection of `vector` onto `base_vector` using the dot product, and
        then scales `base_vector` by this scalar to produce the projected vector.
        """
        projection = self.projection_on_base_scalar(vector, base_vector)
        base_projection = numpy.outer(projection, base_vector)

        return base_projection
